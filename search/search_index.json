{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Web API Grundlagen","text":"<p>Ein Workshop \u00fcber Grundlagen f\u00fcr Web / HTTP APIs vom Code zum App Service, als extra gibt es noch einen Teil f\u00fcr eine Web API welche eine Angular SPA bedient.</p>"},{"location":"api-guidelines/","title":"API Guidelines","text":"<p>Richtlinien f\u00fcr ein Web API.</p>"},{"location":"api-guidelines/#grundlagen","title":"Grundlagen","text":""},{"location":"api-guidelines/#url-struktur","title":"Url Struktur","text":""},{"location":"api-guidelines/#url-l\u00e4nge","title":"Url L\u00e4nge","text":""},{"location":"api-guidelines/#methoden","title":"Methoden","text":"Methode Beschreibung <code>GET</code> Liefert den aktuellen Wert eines Objektes zur\u00fcck. <code>POST</code> Erstellt ein neues Objekt anhand der Daten, die im Body mitgegeben werden. <code>PUT</code> Ersetzt ein bestehendes Objekt mit den Daten, die im Body mitgegeben werden. <code>DELETE</code> L\u00f6scht ein Objekt."},{"location":"api-guidelines/#sammlungen","title":"Sammlungen","text":""},{"location":"api-guidelines/#sammlungsurl-struktur","title":"Sammlungsurl Struktur","text":"<p><code>GET https://{serviceRoot}/{collection}/{id}</code></p>"},{"location":"api-guidelines/#versionierung","title":"Versionierung","text":""},{"location":"api-guidelines/#drosselung-und-limits","title":"Drosselung und limits","text":""},{"location":"api-guidelines/#webhooks","title":"Webhooks","text":""},{"location":"api-guidelines/#benennung","title":"Benennung","text":""},{"location":"api-styles/","title":"API Styles","text":"Style Nutzungsszenario SOAP XML basiert f\u00fcr Enterprise Anwendungen RESTful Resourcen basiert in json f\u00fcr Web Anwendungen HTTP RESTlike bzw. REST bis Level 3 GraphQL Abfragesprache zum reduzieren von Netzwerklast gRPC Bin\u00e4r f\u00fcr High Perfomance Microservices WebSocket Bidirektional f\u00fcr Echzeit Datenaustausch Webhook Asynchrone Kommunikation f\u00fcr Ereignisgesteuerte Architekturen"},{"location":"api-styles/#soap","title":"SOAP","text":""},{"location":"api-styles/#restful","title":"RESTful","text":""},{"location":"api-styles/#http","title":"HTTP","text":""},{"location":"api-styles/#graphql","title":"GraphQL","text":""},{"location":"api-styles/#grpc","title":"gRPC","text":""},{"location":"api-styles/#websocket","title":"WebSocket","text":""},{"location":"api-styles/#webhook","title":"Webhook","text":""},{"location":"backend/","title":"Backend Frameworks","text":""},{"location":"backend/#fastapi","title":"FastAPI","text":""},{"location":"backend/#aspnet","title":"ASP.NET","text":""},{"location":"backend/aspdotnet/","title":"ASP.NET","text":"<p>Webseite</p>"},{"location":"backend/fastapi/","title":"FastAPI","text":"<p>Webseite</p> <p>https://github.com/education/codespaces-project-template-py</p> <p>https://github.com/tiangolo/full-stack-fastapi-postgresql</p>"},{"location":"frontend/","title":"Frontend Framework","text":""},{"location":"frontend/angular/","title":"Angular","text":"<p>Webseite</p>"},{"location":"frontend/nextjs/","title":"Next.js","text":"<p>Webseite</p> <p>https://codevoweb.com/graphql-crud-api-nextjs-mongodb-typegraphql/ https://codevoweb.com/nextjs-full-stack-app-with-react-query-and-graphql-codegen/</p>"},{"location":"frontend/react/","title":"React","text":"<p>Webseite</p>"},{"location":"frontend/vuejs/","title":"Vue.js","text":"<p>Webseite</p>"},{"location":"howto/angular/","title":"ASP.NET Core Web API <code>C#</code> + Angular.js Web SPA <code>TypeScript</code>","text":"<p>In diesem Abschnitt geht es um eine Web API sowie einer SPA. Die Web API l\u00e4uft mit ASP.NET Core und die SPA mit Angular.js.</p>"},{"location":"howto/angular/#voraussetzungen","title":"Voraussetzungen","text":"<ul> <li><code>choco install dotnet-7.0-sdk</code></li> <li><code>npm install -g @angular/cli</code></li> </ul>"},{"location":"howto/angular/#projektstruktur-erstellen","title":"Projektstruktur erstellen","text":"<p><code>dotnet new angular --name Workshop.WebApp --output Workshop.WebApp --language C# --framework net7.0</code></p>"},{"location":"howto/angular/#projekt-starten","title":"Projekt starten","text":"<p>Im Terminal starten wir per dotnet CLI die Anwendung.</p> <p><code>dotnet run</code></p> <p>F\u00fcr eine <code>watch</code>-Funktionalit\u00e4t folgender Befehl: <code>dotnet watch</code></p>"},{"location":"howto/angular/#datenmodel-erstellen","title":"Datenmodel erstellen","text":"<p>Zur\u00fcck zur \u00dcbersicht Weiter zu Abschnitt 3 - ASP.NET Core Web API mit Anuglar.js SPA</p>"},{"location":"howto/aspdotnet/","title":"ASP.NET Core Web API <code>C#</code>","text":"<p>In diesem Abschnitt geht es um eine Web API mit ASP.NET Core welches auf .NET 7 setzt in C# entwickelt wird.</p> <p>.NET bietet die M\u00f6glichkeit Vorlagen zu nutzen um neue Projekte zu erstellen. Es gibt Community und Microsoft Vorlagen, f\u00fcr dieses Projekt nutzen wir die Microsoft Vorlage <code>webapi</code>. In der Vorlage wird eine ASP.NET Web API Anwendung erzeugt, welche einen Wetter Endpunkt bereitstellt. Dieser Endpunkt nimmer aus einer definierten Liste von Wetterereignissen mehrere Zuf\u00e4llige Werte als Antwort sowie zuf\u00e4llige Temperaturen f\u00fcr die kommenden Tage.</p> <p>Themen sichtbar in der Vorlage:</p> <ul> <li>Data Transfer Object (DTO)</li> <li>Computed Properties</li> <li>OpenApi Specification (Swagger)</li> <li>Logging</li> </ul>"},{"location":"howto/aspdotnet/#voraussetzungen","title":"Voraussetzungen","text":"<ul> <li><code>choco install dotnet-5.0-sdk</code></li> <li><code>choco install dotnet-7.0-sdk</code></li> </ul>"},{"location":"howto/aspdotnet/#projektstruktur-erstellen","title":"Projektstruktur erstellen","text":"<p><code>dotnet new webapi --name Workshop.WebApi --output Workshop.WebApi --language C# --framework net5.0</code></p> <p>Weitere Informationen zu .NET Vorlagen</p>"},{"location":"howto/aspdotnet/#projekt-starten","title":"Projekt starten","text":"<p>Projekt lokal starten mit watch <code>dotnet watch --project Workshop.WebApi\\Workshop.WebApi.csproj</code></p> <p>W\u00e4hrend des Debuggens kann man auf den Playground zugreifen und die API ausprobieren. OpenApi Playground</p>"},{"location":"howto/aspdotnet/#api-controller-erstellen","title":"API Controller erstellen","text":"<p>Wir erzeugen uns einen eigenen API Controller mit API Operationen.</p> <p>F\u00fcr Visual Studio</p> <ol> <li>Im Kontextmen\u00fc des <code>Controllers</code> Verzeichnis auf <code>Add</code> klicken und <code>New Item...</code> ausw\u00e4hlen.</li> </ol> <p></p> <ol> <li><code>API Controller - Emtpy</code> ausw\u00e4hlen und einen Namen eingeben, muss im Format <code>&lt;NAME&gt;Controller.cs</code> angegeben werden. Danach mit <code>Add</code> erzeugen. In userem Beispiel nehmen wir <code>EchoController.cs</code>.</li> </ol> <p></p> <p>Alternativ f\u00fcr Visual Studio Code eine Datei erzeugen und den folgenden Code manuell hinzuf\u00fcgen</p> <p>Die Datei / der API Controller sollte nun folgenderma\u00dfen aussehen:</p> <pre><code>// EchoController.cs\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace Workshop.WebApi.Controllers\n{\n[Route(\"api/[controller]\")]\n[ApiController]\npublic class EchoController : ControllerBase\n{\n}\n}\n</code></pre> <p>Nun f\u00fcgen wir eine API Operation hinzu, welche eine Zeichenkette zur\u00fcck gibt.</p> <pre><code>        // GET: /api/Echo/simple\n[HttpGet(\"simple\")]\npublic ActionResult&lt;string&gt; Get() {\nreturn Ok(\"Hallo Welt\");\n}\n</code></pre> <p><code>[HttpGet(\"simple\")]</code> sagt dem Framework, dass die Operation bzw. die folgende Funktion auf die HTTP Methode GET h\u00f6rt und unter der Route <code>api/[controller]/simple</code>, welche zu <code>api/Echo/simple</code> wird, erreichbar ist.</p> <p>Der R\u00fcckgabetyp <code>ActionResult</code> in der Funktionssignatur ist f\u00fcr das HTTP Handling vorhanden. Bei der R\u00fcckgabe der Funktion wird die Funktion <code>Ok</code> (HTTP Status Code 200) mit dem <code>string</code> Parameterwert <code>Hallo Welt</code> \u00fcbergeben.</p> <p>Gern per klick auf <code>Debug</code> dort auf <code>Start Debugging</code> oder <code>F5</code> im Swagger Playground die Operation ausprobieren.</p> <p>Nun bauen wir eine weitere Operation, mit der wir auf Informationen aus dem HTTP Request zugreifen. Wir wollen eine Zeichenkette aus dem Query nehmen und als R\u00fcckgabewert zur\u00fcckliefern.</p> <pre><code>        // // GET: /api/Echo/parameter?msg=&lt;value&gt;\n[HttpGet(\"parameter\")]\npublic ActionResult&lt;string&gt; Parameter([FromQuery] string msg) {\nreturn Ok(msg);\n}\n</code></pre> <p>In der Parametern haben wir nun ein <code>string</code> mit dem Namen <code>msg</code> welcher aus dem Query kommen muss, dank dem Attribut <code>[FromQuery]</code>, Parameter k\u00f6nnen auch noch aus dem Route, Header (Key-Value) oder Body (Json) stammen. Aufbau URL: <code>&lt;PROTOCOL(HTTP|HTTPS&gt;://&lt;FQDN/HOSTNAME(LOCALHOST)&gt;/&lt;PATH/ROUTE(/api/Echo/parameter)&gt;?&lt;QUERY(KEY=VALUE[&amp;])&gt;</code></p> <p>Nun bauen wir eine weitere Operation, in der wir den Parameter <code>msg</code> optional machen und aus der Route erhalten. In der Funktion \u00fcberpr\u00fcfen wir, ob dieser mitgegeben wird, falls nicht werfen wir einen HTTP Status Code 400 - Bad Request zur\u00fcck.</p> <pre><code>        // GET: /api/Echo/validate/&lt;msg&gt;\n[HttpGet(\"validate/{msg}\")]\npublic ActionResult&lt;string&gt; Validate([FromRoute] string msg = null) {\nif (string.IsNullOrWhiteSpace(msg)) {\nreturn BadRequest();\n}\nreturn Ok(msg);\n}\n</code></pre> <p>Die Funktion BadRequest erzeugt ein Objekt des Types ActionResult, welches eine HTTP Response / Antwort mit dem HTTP Status Code 400 erzeugt.</p> <p>Nun erstellen wir einen neuen API Controller mit API CRUD Operationen. Als kleines Beispiel wollen wir Personen als Resource handhaben. Daher nennen wir den API Controller <code>PersonsController.cs</code>. Des Weiteren nehmen wir uns eine Klasse als Data Transfer Object (DTO). Daf\u00fcr erzeugen wir einen neues Verzeichnis <code>Models</code> und dort die Datei <code>Person.cs</code>. Um es einfach zu halten nehmen wir nur einen Identifier <code>id</code> und eine Werte Eigenschaft <code>name</code>.</p> <pre><code>// Person.cs\nnamespace Workshop.WebApi.Models\n{\npublic class Person\n{\npublic int Id { get; set; }\npublic string Name { get; set; }\n}\n}\n</code></pre> <p>Diese k\u00f6nnen wir nun im API Controller verwenden. Um die Daten zur Laufzeit zu persistieren nehmen wir uns dazu ein Dictionary. Ein Dictionary ist ein Key-Value-Speicher und ist im Namespace System.Collections.Generic zu finden damit wir also das Dictionary verwerden k\u00f6nnen, m\u00fcssen wir entweder den Namespace per <code>using</code> einbinden oder den Typen voll ausschreiben <code>System.Collections.Generic.Dictionary</code>.</p> <pre><code>// PersonsController.cs\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Collections.Generic;\nusing Workshop.WebApi.Models;\n\nnamespace Workshop.WebApi.Controllers\n{\n[Route(\"api/[controller]\")]\n[ApiController]\npublic class PersonsController : ControllerBase\n{\nprivate static Dictionary&lt;int, Person&gt; store { get; } = new Dictionary&lt;int, Person&gt; {\n{ 1, new Person{ Id = 1, Name = \"Peter Peterson\" } },\n{ 2, new Person{ Id = 2, Name = \"Klaus Klausens\" } },\n{ 3, new Person{ Id = 3, Name = \"Singa Singable\" } },\n};\n}\n}\n</code></pre> <p>Nun erstellen wir die Read (cRud - GET) Operationen, einmal einen Endpunkt f\u00fcr alle Personen und einen f\u00fcr eine Person.</p> <pre><code>        [HttpGet]\npublic ActionResult&lt;IEnumerable&lt;Person&gt;&gt; GetPersons() {\nreturn Ok(store.Values.ToList());\n}\n\n[HttpGet(\"{id}\", Name = nameof(GetPersonById))]\npublic ActionResult GetPersonById(int id) {\nreturn Ok(store[id]);\n}\n</code></pre> <p>Bei der Create (Crud - POST) Operation \u00fcberpr\u00fcfen wir erstmal, ob nicht bereits ein Eintrag mit der <code>Id</code> vorhanden ist. Wenn der Zustand des Models valide ist, wird das Model dem Store hinzugef\u00fcgt und eine HTTP Status Code 201 Antwort zur\u00fcck gegeben. Der Status Code 201 erwartet eine Url im Header mit dem Key <code>location</code>.</p> <pre><code>        [HttpPost]\npublic ActionResult PostPerson([FromBody] Person person) {\nif (store.ContainsKey(person.Id)) {\nModelState.AddModelError(nameof(person.Id), \"Resource with the id already exists\");\n}\nif (ModelState.IsValid) {\nstore.Add(person.Id, person);\nreturn CreatedAtRoute(nameof(GetPersonById), new { person.Id }, person);\n}\nreturn BadRequest(ModelState.ValidationState);\n}\n</code></pre> <p>Jetzt folgt die Update (crUd - PUT) Operation, zuerst schauen wir, ob ein Eintrag mit der <code>Id</code> existiert und ob der Zustand des Models valide ist. Falls alles zutrifft, wird die Person im Store aktualisiert / \u00fcberschrieben. Die Antwort f\u00fcr eine PUT Operation ist ein Status Code 204.</p> <pre><code>        [HttpPut(\"{id}\")]\npublic ActionResult PutPerson([FromRoute] int id, [FromBody] Person person) {\nif (!store.ContainsKey(id)) { return NotFound(); }\nif (!ModelState.IsValid) { return BadRequest(ModelState.ValidationState); }\nstore[id] = person;\nreturn NoContent();\n}\n</code></pre> <p>Bei der Delete (cruD - DELETE) Operation, \u00fcberpr\u00fcfen wir ebenfalls im Store ob eine Person mit der Id existiert.</p> <pre><code>        [HttpDelete(\"{id}\")]\npublic ActionResult DeletePerson([FromRoute] int id) {\nif (!store.ContainsKey(id)) { return NotFound(); }\nstore.Remove(id);\nreturn NoContent();\n}\n</code></pre> <p>Alternativ zum Swagger Playground kann auch der Postman genutzt werden.</p> <p>Damit der Swagger Playground auch au\u00dferhalb der Entwicklung funktioniert m\u00fcssen wir die <code>Startup.cs</code> bearbeiten.</p> <pre><code>            if (env.IsDevelopment()) {\napp.UseDeveloperExceptionPage();\napp.UseSwagger();\napp.UseSwaggerUI(c =&gt; c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"Workshop.WebApi v1\"));\n}\napp.UseHttpsRedirection();\n</code></pre> <p>Die Aufrufe UseSwagger() und UseSwaggerUI() m\u00fcssen aus dem If-Block unter dem Aufruf UseHttpsRedirection().</p> <pre><code>            if (env.IsDevelopment()) {\napp.UseDeveloperExceptionPage();\n}\napp.UseHttpsRedirection();\napp.UseSwagger();\napp.UseSwaggerUI(c =&gt; c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"Workshop.WebApi v1\"));\n</code></pre>"},{"location":"howto/aspdotnet/#anwendung-bauen--bereitstellen","title":"Anwendung bauen &amp; bereitstellen","text":"<p>Anwendung bauen</p> <p><code>dotnet build --configuration Release .\\Workshop.WebApi\\Workshop.WebApi.csproj</code></p> <p>Anwendung ver\u00f6ffentlichen</p> <p><code>dotnet publish --no-build -c Release -o .\\Workshop.WebApi\\bin\\publish .\\Workshop.WebApi\\Workshop.WebApi.csproj</code></p> <p>Zur\u00fcck zur \u00dcbersicht Weiter zu Abschnitt 2 - Node.js API mit Nest.js</p>"},{"location":"howto/fastapi/","title":"FastAPI WebAPI <code>python</code>","text":"<p>In diesem Abschnitt geht es um eine Web API mit FastAPI in python.</p>"},{"location":"howto/fastapi/#voraussetzungen","title":"Voraussetzungen","text":"<p>Neue virtuelle Umbegung aufbauen. <code>python3 -m venv .venv</code></p> <p>Neue Umgebung aktivieren <code>.venv/bin/activate</code></p> <p>Notwendige Pakete installieren</p> <ul> <li><code>pip install fastapi</code></li> <li><code>pip install uvicorn</code></li> </ul>"},{"location":"howto/fastapi/#projektstruktur-erstellen","title":"Projektstruktur erstellen","text":"<p>Unterordner manuell erstellen f\u00fcr den Code beispielsweise <code>app</code> oder <code>src</code>.</p> <p>Dort die <code>main.py</code> Datei erzeugen. In der Datei tragen wir nun ein erste, kleine Anwendung ein.</p> <pre><code># main.py\nfrom fastapi import FastAPI\napp = FastAPI()\n\n@app.get(\"/\")\nasync def root():\n return { \"greeting\": \"Hello world\" }\n</code></pre> <p>Es wird eine neue FastAPI Anwendung erzeugt und eine Funktion bekommt \u00fcber die get Attributsfunktion die Ausf\u00fchrbarkeit bzw. einen Endpunkt.</p>"},{"location":"howto/fastapi/#projekt-starten","title":"Projekt starten","text":"<p>Im Terminal starten wir per uvicorn die Anwendung. Falls anstelle von <code>app</code> der Ordnername <code>src</code> gew\u00e4hlt wurde, muss der Befehlt dementsprechend angepasst werden.</p> <p><code>uvicorn app.main:app --host localhost --port 8000 --reload</code></p> <p>Projekt starten mit Ordner <code>src</code>.</p> <p><code>uvicorn src.main:app --host localhost --port 8000 --reload</code></p>"},{"location":"howto/fastapi/#datenmodel-erstellen","title":"Datenmodel erstellen","text":""},{"location":"howto/fastapi/#api-controller-erstellen","title":"API Controller erstellen","text":"<p>Zur\u00fcck zur \u00dcbersicht Weiter zu Abschnitt 4 - ASP.NET Core Web API mit Anuglar.js SPA</p>"},{"location":"howto/flask/","title":"Flask Web Api <code>python</code>","text":"<p>In diesem Abschnitt geht es um eine Web API mit Flask in python.</p>"},{"location":"howto/flask/#voraussetzungen","title":"Voraussetzungen","text":"<p>Neue virtuelle Umgebung aufbauen. <code>python3 -m venv .venv</code></p> <p>Neue Umgebung aktivieren <code>.venv/bin/activate</code></p> <p>Notwendige Pakete installieren</p> <ul> <li><code>pip install Flask</code></li> </ul>"},{"location":"howto/flask/#projektstruktur-erstellen","title":"Projektstruktur erstellen","text":"<p>Unterordner manuell erstellen f\u00fcr den Code beispielsweise <code>app</code> oder <code>src</code>.</p> <p>Dort die <code>main.py</code> Datei erzeugen. In der Datei tragen wir nun ein erste, kleine Anwendung ein.</p> <pre><code>from flask import Flask\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello_world():\n    return \"Hello, World!\"\n</code></pre> <p>Es wird eine neue Flask Anwendung erzeugt und eine Funktion bekommt \u00fcber die get Attributsfunktion die Ausf\u00fchrbarkeit bzw. einen Endpunkt.</p>"},{"location":"howto/flask/#projekt-starten","title":"Projekt starten","text":"<p>Im Terminal starten wir per uvicorn die Anwendung. Falls anstelle von <code>app</code> der Ordnername <code>src</code> gew\u00e4hlt wurde, muss der Befehlt dementsprechend angepasst werden.</p> <p><code>flask --app main run</code></p>"},{"location":"howto/nestjs/","title":"Node.js mit Nest.js Web API <code>TypeScript</code>","text":"<p>In diesem Abschnitt geht es um eine Web API mit Nest.js in TypeScript.</p>"},{"location":"howto/nestjs/#voraussetzungen","title":"Voraussetzungen","text":"<ul> <li><code>choco install nodejs-lts</code></li> <li><code>npm install -g @nestjs/cli</code></li> </ul>"},{"location":"howto/nestjs/#projektstruktur-erstellen","title":"Projektstruktur erstellen","text":"<p><code>nest new WorkshopNodeApi --skip-git --package-manager npm --language TS</code></p>"},{"location":"howto/nestjs/#projekt-starten","title":"Projekt starten","text":"<p>Projekt lokal starten mit watch-Funktionalit\u00e4t: <code>npm run start:dev</code></p>"},{"location":"howto/nestjs/#api-controller-erstellen","title":"API Controller erstellen","text":"<p><code>nest generate controller echo</code> | <code>nest g co echo</code></p> <p>Dadurch wird ein neue API Controller ezeugt und in der <code>app.modules.ts</code> verkn\u00fcpft.</p> <pre><code>// src/echo/echo.controller.ts\nimport { Controller } from \"@nestjs/common\";\n\n@Controller(\"echo\")\nexport class EchoController {}\n</code></pre> <p>In der erstellten <code>src/echo/echo.controller.ts</code> \u00e4ndern wir den pfad von <code>/echo</code> auf <code>/api/echo</code> indem wir den Parameter im Controller Attribut \u00e4ndern auf <code>/api/echo</code>.</p> <pre><code>// src/echo/echo.controller.ts\nimport { Controller } from \"@nestjs/common\";\n\n@Controller(\"/api/echo\")\nexport class EchoController {}\n</code></pre> <p>Nun erweitern wir die <code>EchoController</code> Klasse, mit den selben API Operationen wie im ersten Abschnitt.</p> <p>Die erste Operation gab nur die Zeichenkette <code>Hallo Welt</code> zur\u00fcck, in <code>NEST.js</code> gibt es ebenfalls Attribute f\u00fcr das manipulieren von Routen. Dem <code>Get</code>-Attribut geben wir als Parameter die Route an, die nach der Controller Route angehangen wird.</p> <pre><code>    @Get('simple')\nsimple(): string {\nreturn \"Hallo Welt\";\n}\n</code></pre> <p>Eigenschaften f\u00fcr Parameter werden ebenfalls als Attribut angegeben daher nehmen wir jetzt die Nachricht bzw <code>msg</code> aus dem Query. Anstelle von <code>@Query</code> kann hier ebenfalls die Route mit <code>@Param</code>, der Header mit <code>@Header</code> oder der Body mit <code>@Body</code> ausgew\u00e4hlt werden.</p> <pre><code>    @Get('parameter')\nparameter(@Query() msg: string): string {\nreturn msg;\n}\n</code></pre> <p>Bei der letzten Echo Operationen tauschen wir die Herkunft des <code>msg</code> Parameters vom Query zur Route, daf\u00fcr m\u00fcssen wir in der Route diesen angeben. Fehler HTTP Status Codes werden bei NEST mit Exceptions geworfen. Daher werden wir eine BadRequestException wenn die Anfrage fehlerhaft ist.</p> <pre><code>    @Get('validate/:msg?')\nvalidate(@Param('msg') msg: string | undefined = undefined): string {\nif (!msg) {\nthrow new BadRequestException(msg, \"msg undefined\");\n}\nreturn msg;\n}\n</code></pre> <p>Nun bauen wir den API Controller mit CRUD API Operationen in NEST nach.</p> <p><code>nest generate class person</code></p> <p>Anfangen tun wir mit dem DTO bzw. der Klasse Person.</p> <pre><code>// src/person.ts\nexport class Person {\nid: number;\nname: string;\n}\n</code></pre> <p>Nun wollen wir einen Speicher erzeugen um die Personen w\u00e4hrend der Laufzeit zu persistieren. Daf\u00fcr erzeugen wir einen Service indem wir diese Speichern.</p> <p><code>nest generate service persons</code></p> <pre><code>// src/persons/persons.service.ts\nimport { Injectable, Scope } from \"@nestjs/common\";\n\n@Injectable()\nexport class PersonsService {}\n</code></pre> <p>Services in NEST werden durch Dependency Injection in die Controller gebracht, der Standard Scope ist <code>singleton</code>. Dies bedeutet die Instanz des Services ist persistent \u00fcber die Laufzeit der Anwendung. Es gibt noch die M\u00f6glichkeit den Scope pro Anfrage / Request neu erzeugen zu lassen.</p> <p><code>@Injectable({ scope: Scope.DEFAULT })</code></p> <p>Wir bleiben erstmal bei dem Konzept des Key-Value Pairs.</p> <pre><code>import { Injectable, Scope } from \"@nestjs/common\";\nimport { Person } from \"../person\";\n\n@Injectable({ scope: Scope.DEFAULT })\nexport class PersonsService {\nprivate store: Map&lt;number, Person&gt; = new Map([\n[1, { id: 1, name: \"Peter Peterson\" }],\n[2, { id: 2, name: \"Klaus Klausens\" }],\n[3, { id: 3, name: \"Singa Singable\" }],\n]);\nlist(): Person[] {\nreturn Array.from(this.store.values());\n}\nget(id: number): Person {\nreturn this.store.get(id);\n}\nexists(id: number): boolean {\nreturn this.store.has(id);\n}\ndelete(id: number): boolean {\nreturn this.store.delete(id);\n}\ncreate(person: Person): void {\nthis.store.set(person.id, person);\n}\nupdate(id: number, person: Person): void {\nthis.store.set(id, person);\n}\n}\n</code></pre> <p>Auch f\u00fcr den Controller gibt es bei Nest.js CLI ein Befehl zum erzeugen. <code>nest generate controller persons</code> Der Controller bekommt eine Route und einen Konstruktor, welcher den Service erwartet.</p> <pre><code>@Controller(\"/api/persons\")\nexport class PersonsController {\nconstructor(private readonly service: PersonsService) {}\n}\n</code></pre> <p>Dann geht es mit den Get API Operationen weiter, wir rufen dort den Service auf und geben die R\u00fcckgabe der Funktion zur\u00fcck. Wichtig dabei zu wissen, Parameter aus der Route m\u00fcssen string sein und k\u00f6nnen nicht number sein, weshalb wir diese \u00fcberpr\u00fcfen und bei Bedarf in eine Nummer wandeln.</p> <pre><code>    @Get()\ngetPersons(): Person[] {\nreturn this.service.list();\n}\n\n@Get(':id')\ngetPersonById(@Param('id') id: string): Person {\nif(Number.parseInt(id)) {\nreturn this.service.get(Number.parseInt(id));\n}\nthrow new BadRequestException(id, \"id is no number\");\n}\n</code></pre> <p>F\u00fcr die Create Operation gibt es automatisch ein 201 Status Code zur\u00fcck, jedoch ohne <code>location</code> Header.</p> <pre><code>    @Post()\npostPerson(@Body() person: Person): any {\nreturn this.service.create(person);\n}\n</code></pre> <p>Bei der Update Operation gibt es nichts nichts besonderes, wir \u00fcberpr\u00fcfen, ob die <code>id</code> eine Nummer ist, \u00fcberpr\u00fcfen ob die <code>id</code> im Store vorhanden ist und aktualisieren die Person.</p> <pre><code>    @Put(':id')\nputPerson(@Param('id') id: string, @Body() person: Person): any {\nif (Number.parseInt(id)) {\nif (!this.service.exists(Number.parseInt(id))) {\nthrow new NotFoundException();\n}\nreturn this.service.update(Number.parseInt(id), person);\n}\nthrow new BadRequestException(id, \"id is no number\");\n}\n</code></pre> <p>Die Delete Operation ist ebenfalls nichts besonderes.</p> <pre><code>    @Delete(':id')\n@HttpCode(HttpStatus.NO_CONTENT)\ndeletePerson(@Param('id') id: string): any {\nif (Number.parseInt(id)) {\nif (!this.service.exists(Number.parseInt(id))) {\nthrow new NotFoundException();\n}\nthis.service.delete(Number.parseInt(id));\nreturn;\n}\nthrow new BadRequestException(id, \"id is no number\");\n}\n</code></pre> <p>Zur\u00fcck zur \u00dcbersicht Weiter zu Abschnitt 3 - ASP.NET Core Web API mit Anuglar.js SPA</p>"}]}